Renesas RX Microcontroller Hardware Definition (Common) Template
=========

[Japanese](READMEja.md)

## Overview

Hardware Definition C++ Framework for Renesas RX Series   

- Hardware definitions provided by Renesas are highly environment-dependent
- Implemented for the C language, using it with C++ has many negative effects
- Many implementations violate language conventions and are not recommended.
- Very verbose and poorly readable
- It is generated by another tool and is inconsistent.
- Not available without a separate tool.
- Generic keywords are defined in “#define” and contaminate keywords of the same name in the namespace
- Cannot be shared because of partial differences between RX microcontrollers.
   
Hardware definitions using C++ templates can be compiled error-free with C++17 or later compilers.   
The hardware definitions utilizing C++ templates can be compiled without errors with C++17 or later compilers, and use formal names that conform to the register descriptions in   the hardware manuals.   
The hardware definitions using the C++ template can be compiled without error on C++17 or    later compilers.   
In “iodefine.h”, due to the structure of bit field definitions, it is necessary to add    different instances for bit access and word access.   
The “iodefine.h” is redundant because it is necessary to add different instances for bit   access and word access due to the structure of the bit field definitions.   
   
The source code is divided by module according to the hardware manual.   
   
Since it is a template class, optimization can be maximized, and if necessary, there is   room for further implementation for optimization.   
   
It uses C++ functionality to absorb the subtle differences between different hardware    through structural access, reference access, etc.   
   
Each device module is referred to in this framework as a “peripheral.”   
      
## Peripheral Name

- To identify each device module, a peripheral name is defined
- Peripheral names are defined in the RXxxx/peripheral.hpp file.
- Peripheral names are defined in the RXxxx/peripheral.hpp file.
- These names are used as identifiers in various situations, such as power-saving switching, port control, interrupt control, etc.
- The names are used to automate the detailed configuration required throughout the framework.
- Note that the name of a peripheral may be the same as the name of the class that defines the peripheral.
- Peripheral names are defined as scoped enums in the “peripheral” space.
   
## Clock profile definition

- There are several clocks generated by each microcontroller and they differ from module to module
- There are several clocks generated by each microcontroller and they differ from module to module: BASE, PLL_BASE, PCLKA, PCLKB, PCLKC, PCLKD, FCLK, BCLK, etc.
- It is defined in the file RXxxx/clock_profile.hpp
- This clock frequency is referenced, if needed, and is defined for each module class.
- Each module, and the driver that controls it, refers to this clock frequency to determine its period.
- The frequency is defined as an integer (if it is not divisible, be careful to handle errors)
   
## Power saving control

- Defined in the file RXxxx/power_mgr.hpp
- Performs power control using peripheral names as keys.
   
## Interrupt vector name

- Defined in RXxxx/icu.hpp file
- Interrupt vectors handled by each device are also defined for abstraction
- Interrupt vectors have specific types, such as normal vectors, group vectors, and selective vectors.
- The different types are used to ensure that the configuration method is consistent, even when different configuration methods are used.
   
## Port mapping

- Each device module of RX microcontroller uses I/O ports as input/output.
- Since these ports are used exclusively, it is necessary to set which input/output is assigned to which port.
- Port assignment is limited and there are several candidates
- The port map class implements a mechanism that allows specification by candidate and by group
- The RXxxx/port_map.hpp file defines the basic port candidates.
- Using this mechanism, each driver class can select and switch to a specified port.
- The candidate ports can be selected with the simplest possible specification.
- The “candidates” are based on the “List of Assigned Multifunction Pins” of the MPC (Multi-function Pin Controller) in the Hardware Manual.
   
## Convenience functions

- Each device class has various mechanisms to handle operations from driver and service classes in a more abstract way
- Each device class may have functions that allow operations to be performed in a concise manner
   
## Namespace

- We use “device” as the namespace for devices.
   
## Board profile definition

- For each microcontroller, a file that consolidates hardware-dependent definitions is provided.
- The definitions are in the file RXxxx/board_profile.hpp
- This file contains commonly used definitions such as LED ports, SCI ports, CMT channels, etc.
- Many of the sample application programs refer to and use these definitions.
- Therefore, the sample applications do not need to be aware of the settings specific to each microcontroller.
   
---

## Solution for use with iodefine.h

 - There are cases where you want to use the sample programs and drivers provided by Renesas in conjunction with iodefine.h.
 - In such a case, you may need to use “iodefine.h” together with C++ classes.
 - In such cases, a generic name will be used (e.g., “USB”).
 - In such cases, the generic name will be used (e.g. “USB”) because it may be defined by “#define” in “iodefine.h
 - In this case, you need to change “iodefine.h” to a name that does not hit the target, and modify the source code provided by Renesas.
 - C++ template classes are pushed into the namespace and usually do not hit, but if “#define” is used, there is nothing that can be done.
 - Changing the “hit” names in the C++ template classes would be a major modification and is not recommended.
 - The other way is to completely separate the source code that uses “idodefine.h” from the source code that uses the C++ framework
 - When calling a C++ function from a C source, use “extern ‘C’” to define the function in C++, in which case the prototype should be C compliant
    
---

## Supported RX microcontrollers (directory)

|RX Microcontroller|operation verification|
|:-:|:-:|
|[RX13T](../RX13T)|-|
|[RX23T](../RX23T)|-|
|[RX24T](../RX24T)|〇|
|[RX24U](../RX24U)|-|
|[RX26T](../RX26T)|〇|
|[RX26x (RX260/RX261)](../RX26x)|-|
|[RX62x (RX621/RX62N)](../RX62x)|〇|
|[RX63T](../RX63T)|〇|
|[RX63x (RX631/RX63N)](../RX63x)|〇|
|[RX64M](../RX64M)|〇|
|[RX65x (RX651/RX65N)](../RX65x)|〇|
|[RX66N](../RX66N)|-|
|[RX66T](../RX66T)|〇|
|[RX71M](../RX71M)|〇|
|[RX72M](../RX72M)|-|
|[RX72N](../RX72N)|〇|
|[RX72T](../RX72T)|〇|
|[RX110](../RX110)|-|
|[RX111](../RX111)|-|
|[RX113](../RX113)|-|
|[RX130](../RX130)|-|
|[RX140](../RX140)|〇|
|[RX220](../RX220)|〇|
|[RX231](../RX231)|〇|
|[RX660](../RX660)|-|
|[RX671](../RX671)|-|

---

## RX Microcontroller Device File

|File|Functions|Class|
|---|---|---|
|[bus.hpp](bus.hpp?ts=4)|Buses|BUS|
|[cac.hpp](cac.hpp?ts=4)|Clock Frequency Accuracy Measurement Circuit|CAC|
|[can.hpp](can.hpp?ts=4)|CAN Module|CAN|
|[canfd.hpp](canfd.hpp?ts=4)|CAN FD Module|CANFD|
|[cmpc.hpp](cmpc.hpp?ts=4)|Comparator C|CMPC|
|[cmt.hpp](cmt.hpp?ts=4)|Compare Match Timer|CMT|
|[cmtw.hpp](cmtw.hpp?ts=4)|Compare Match Timer W|CMTW|
|[crc.hpp](crc.hpp?ts=4)|CRC Calculator|CRC|
|[crca.hpp](crca.hpp?ts=4)|CRC Calculator A|CRCA|
|[ctsu.hpp](ctsu.hpp?ts=4)|Capacitive Touch Sensing Unit|CTSU|
|[ctsu2.hpp](ctsu2.hpp?ts=4)|Capacitive Touch Sensing Unit 2|CTSU2|
|[dmac.hpp](dmac.hpp?ts=4)|DMA Controller|DMAC|
|[doc.hpp](doc.hpp?ts=4)|Data Operation Circuit|DOC|
|[doca.hpp](doca.hpp?ts=4)|Data Operation Circuit A|DOCA|
|[drw2d.hpp](drw2d.hpp?ts=4)|2D Drawing Engine|DRW2D|
|[dsmif.hpp](dsmif.hpp?ts=4)|Delta-Sigma Modulator Interface|DSMIF|
|[dtc.hpp](dtc.hpp?ts=4)|Data Transfer Controller|DTC|
|[edmac.hpp](edmac.hpp?ts=4)|DMA Controller for the Ethernet Controller|EDMAC|
|[elc.hpp](elc.hpp?ts=4)|Event Link Controller|ELC|
|[eptpc.hpp](eptpc.hpp?ts=4)|PTP Module for the Ethernet Controller|EPTPC|
|[esc.hpp](esc.hpp?ts=4)|EtherCAT Slave Controller|ESC|
|[etherc.hpp](etherc.hpp?ts=4)|Ethernet Controller|ETHERC|
|[exdmac.hpp](exdmac.hpp?ts=4)|EXDMA Controller|EXDMAC|
|[flash.hpp](flash.hpp?ts=4)|Flash Memory|FLASH|
|[glcdc.hpp](glcdc.hpp?ts=4)|Graphic LCD Controller|GLCDC|
|[gpt.hpp](gpt.hpp?ts=4)|General PWM Timer|GPT|
|[gptw.hpp](gptw.hpp?ts=4)|General PWM Timer|GPTW|
|[hrpwm.hpp](hrpwm.hpp?ts=4)|High Resolution PWM Waveform Generation Circuit|HRPWM|
|[iwdt.hpp](iwdt.hpp?ts=4)|Independent Watchdog Timer|IWDT|
|[lcdc.hpp](lcdc.hpp?ts=4)|LCD Controller / Driver|LCDC|
|[lpt.hpp](lpt.hpp?ts=4)|Low-Power Timer|LPT|
|[lvda.hpp](lvda.hpp?ts=4)|Voltage Detection Circuit|LVDA|
|[mmcif.hpp](mmcif.hpp?ts=4)|MultiMediaCard Interface|MMCIF|
|[mpu.hpp](mpu.hpp?ts=4)|Memory-Protection Unit|MPU|
|[mtu3.hpp](mtu3.hpp?ts=4)|Multi-Function Timer Pulse Unit 3|MTU3|
|[pdc.hpp](pdc.hpp?ts=4)|Parallel Data Capture Unit|PDC|
|[pmgi.hpp](pmgi.hpp?ts=4)|PHY Management Interface|PMGI|
|[poe3d.hpp](poe3d.hpp?ts=4)|Port Output Enable 3 |POE3|
|[poeg.hpp](poeg.hpp?ts=4)|Port Output Enable for GPTW|POEG|
|[ppg.hpp](ppg.hpp?ts=4)|Programmable Pulse Generator|PPG|
|[qspi.hpp](qspi.hpp?ts=4)|Quad Serial Peripheral Interface|QSPI|
|[qspix.hpp](qspix.hpp?ts=4)|Quad-SPI Memory Interface|QSPIX|
|[r12da.hpp](r12da.hpp?ts=4)|12-Bit D/A Converter|R12DA|
|[remc.hpp](remc.hpp?ts=4)|Remote Control Signal Receiver|REMC|
|[ri3c.hpp](ri3c.hpp?ts=4)|I3C-bus Interface|RI3C|
|[riic.hpp](riic.hpp?ts=4)|I2C-bus Interface|RIIC|
|[riichs.hpp](riichs.hpp?ts=4)|High-speed I2C-bus Interface|RIICHS|
|[rscan.hpp](rscan.hpp?ts=4)|RSCAN Module|RSCAN|
|[rsci.hpp](rsci.hpp?ts=4)|Serial Communications Interface|RSCI|
|[rspi.hpp](rspi.hpp?ts=4)|Serial Peripheral Interface|RSPI|
|[rspia.hpp](rspia.hpp?ts=4)|Serial Peripheral Interface A|RSPIA|
|[rtc.hpp](rtc.hpp?ts=4)|Realtime Clock|RTC|
|[s12adf.hpp](s12adf.hpp?ts=4)|12-Bit A/D Converter|S12ADC|
|[sci_a.hpp](sci_a.hpp?ts=4)|Serial Communications Interface a|SCIa|
|[sci_c.hpp](sci_c.hpp?ts=4)|Serial Communications Interface c|SCIc|
|[sci_d.hpp](sci_d.hpp?ts=4)|Serial Communications Interface d|SCId|
|[sci_e.hpp](sci_e.hpp?ts=4)|Serial Communications Interface e|SCIe|
|[sci_f.hpp](sci_f.hpp?ts=4)|Serial Communications Interface f|SCIf|
|[sci_g.hpp](sci_g.hpp?ts=4)|Serial Communications Interface g|SCIg|
|[sci_h.hpp](sci_h.hpp?ts=4)|Serial Communications Interface h|SCIh|
|[sci_i.hpp](sci_i.hpp?ts=4)|Serial Communications Interface i|SCIi|
|[sci_j.hpp](sci_j.hpp?ts=4)|Serial Communications Interface j|SCIj|
|[sci_k.hpp](sci_k.hpp?ts=4)|Serial Communications Interface k|SCIk|
|[sci_m.hpp](sci_m.hpp?ts=4)|Serial Communications Interface m|SCIm|
|[scif.hpp](scif.hpp?ts=4)|Serial Communications Interface with FIFO|SCIF|
|[sdhi.hpp](sdhi.hpp?ts=4)|SD Host interface|SDHI|
|[sdsi.hpp](sdsi.hpp?ts=4)|SD Slave interface|SDSI|
|[src.hpp](src.hpp?ts=4)|Sampling Rate Converter|SRC|
|[ssi.hpp](ssi.hpp?ts=4)|Serial Sound Interface|SSI|
|[ssie.hpp](ssie.hpp?ts=4)|Extension Serial Sound Interface|SSIE|
|[system.hpp](system.hpp?ts=4)|Clock Generation Circuit/etc.|SYSTEM|
|[tfu.hpp](tfu.hpp?ts=4)|Trigonometrical function calculator|TFU|
|[tmr.hpp](tmr.hpp?ts=4)|8-Bit Timer|TMR|
|[tpu.hpp](tpu.hpp?ts=4)|16-Bit Timer plus unit|TPU|
|[usb.hpp](usb.hpp?ts=4)|USB 2.0 FS Host/Function Module|USB|
|[usba.hpp](usba.hpp?ts=4)|USB 2.0 Full-Speed Host/Function Module|USBA|
|[vbatt.hpp](vbatt.hpp?ts=4)|Battery Backup Function|VBATT|
|[wdta.hpp](wdta.hpp?ts=4)|Watchdog Timer|WDT|


## RX Microcontroller Support Files

|File|Functions|
|---|---|
|[ad_utils.hpp](ad_utils.hpp?ts=4)|A/D Conversion Utility|
|[adc_in.hpp](adc_in.hpp?ts=4)|A/D Input|
|[adc_in_base.hpp](adc_in_base.hpp?ts=4)|A/D A/D Conversion Base|
|[bus_mgr.hpp](bus_mgr.hpp?ts=4)|Bus Manager|
|[can_frame.hpp](can_frame.hpp?ts=4)|CAN frame definition|
|[canfd_frame.hpp](canfd_frame.hpp?ts=4)|CAN FD frame definition|
|[dac_out.hpp](dac_out.hpp?ts=4)|D/A Output|
|[dmac_mgr.hpp](dmac_mgr.hpp?ts=4)|DMAC Manager|
|[drw2d_mgr.hpp](drw2d_mgr.hpp?ts=4)|DRW2D Manager|
|[ether_io.hpp](ether_io.hpp?ts=4)|イーサーネット入出力|
|[flash_io.hpp](flash_io.hpp?ts=4)|Flash memory input/output|
|[flash_io_base.hpp](flash_io_base.hpp?ts=4)|Flash memory input/output base|
|[glcdc_def.hpp](glcdc_def.hpp?ts=4)|GLCDC basic definition|
|[glcdc_mgr.hpp](glcdc_mgr.hpp?ts=4)|GLCDC Manager|
|[icu_base.hpp](icu_base.hpp?ts=4)|割り込み制御ベース|
|[icu_utils.hpp](icu_utils.hpp?ts=4)|割り込み制御ユーティリティ|
|[mtu_base.hpp](mtu_base.hpp?ts=4)|MTU base|
|[port_base.hpp](port_base.hpp?ts=4)|PORT base|
|[port_map_irq.hpp](port_map_irq.hpp?ts=4)|IRQ port map|
|[port_map_order.hpp](port_map_order.hpp?ts=4)|port map order|
|[rtc_io.hpp](rtc_io.hpp?ts=4)|RTC Input/Output|
|[sci_base.hpp](sci_base.hpp?ts=4)|SCI base|
|[sdram.hpp](sdram.hpp?ts=4)|SDRAM Setting|
|[ssi_io.hpp](ssi_io.hpp?ts=4)|SSI Input/Output|
|[ssie_io.hpp](ssie_io.hpp?ts=4)|SSIE Input/Output|
|[standby_ram.hpp](standby_ram.hpp?ts=4)|Standby RAM Controle|
|[system_io.hpp](system_io.hpp?ts=4)|クロック制御など|

---
   
Special thanks:   
   
Translated with DeepL.com (free version)   
   
---
   
License

MIT